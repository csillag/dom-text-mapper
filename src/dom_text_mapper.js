// Generated by CoffeeScript 1.4.0
(function() {

  window.DomTextMapper = (function() {
    var CONTEXT_LEN, USE_TABLE_TEXT_WORKAROUND, USE_THEAD_TBODY_WORKAROUND;

    USE_THEAD_TBODY_WORKAROUND = true;

    USE_TABLE_TEXT_WORKAROUND = true;

    CONTEXT_LEN = 32;

    function DomTextMapper() {
      this.setRealRoot();
      this.restrictToSerializable(false);
    }

    DomTextMapper.prototype.restrictToSerializable = function(value) {
      if (value == null) {
        value = true;
      }
      return this.restricted = value;
    };

    DomTextMapper.prototype.setRootNode = function(rootNode) {
      this.rootWin = window;
      return this.pathStartNode = this.rootNode = rootNode;
    };

    DomTextMapper.prototype.setRootId = function(rootId) {
      return this.setRootNode(document.getElementById(rootId));
    };

    DomTextMapper.prototype.setRootIframe = function(iframeId) {
      var iframe;
      iframe = window.document.getElementById(iframeId);
      if (iframe == null) {
        throw new Error("Can't find iframe with specified ID!");
      }
      this.rootWin = iframe.contentWindow;
      if (this.rootWin == null) {
        throw new Error("Can't access contents of the spefified iframe!");
      }
      this.rootNode = this.rootWin.document;
      return this.pathStartNode = this.getBody();
    };

    DomTextMapper.prototype.setRealRoot = function() {
      this.rootWin = window;
      this.rootNode = document;
      return this.pathStartNode = this.getBody();
    };

    DomTextMapper.prototype.documentChanged = function() {
      return this.lastDOMChange = this.timestamp();
    };

    DomTextMapper.prototype.getAllPaths = function() {
      var cleanInfo, info, path, startTime, _ref;
      if (this.domStableSince(this.lastCollectedPaths)) {
        if (this.restricted) {
          return this.cleanPaths;
        } else {
          return this.allPaths;
        }
      }
      startTime = this.timestamp();
      this.saveSelection();
      this.allPaths = {};
      this.collectPathsForNode(this.pathStartNode);
      this.restoreSelection();
      this.lastCollectedPaths = this.timestamp();
      console.log("Path traversal took " + (this.lastCollectedPaths - startTime) + " ms.");
      if (this.restricted) {
        this.cleanPaths = {};
        _ref = this.allPaths;
        for (path in _ref) {
          info = _ref[path];
          cleanInfo = $.extend({}, info);
          delete cleanInfo.node;
          this.cleanPaths[path] = cleanInfo;
        }
        return this.cleanPaths;
      } else {
        return this.allPaths;
      }
    };

    DomTextMapper.prototype.getDefaultPath = function() {
      return this.getPathTo(this.pathStartNode);
    };

    DomTextMapper.prototype.selectPath = function(path, scroll) {
      var info, _ref;
      if (scroll == null) {
        scroll = false;
      }
      info = this.allPaths[path];
      return this.selectNode((_ref = info.node) != null ? _ref : this.lookUpNode(info.path));
    };

    DomTextMapper.prototype.scan = function(path) {
      var node;
      if (path == null) {
        path = null;
      }
      if (path == null) {
        path = this.getDefaultPath();
      }
      if (path === this.scannedPath && this.domStableSince(this.lastScanned)) {
        return;
      }
      this.getAllPaths();
      node = this.allPaths[path].node;
      this.mappings = {};
      this.saveSelection();
      this.collectStrings(node, path, null, 0, 0);
      this.restoreSelection();
      this.scannedPath = path;
      this.lastScanned = this.timestamp();
      this.corpus = this.mappings[path].pathInfo.content;
      return null;
    };

    DomTextMapper.prototype.performUpdateOnNode = function(node, escalating) {
      var data, oldIndex, p, parentMappings, parentNode, parentPath, parentPathInfo, path, pathInfo, pathsToDrop, prefix, startTime, _i, _len, _ref;
      if (escalating == null) {
        escalating = false;
      }
      if (node == null) {
        throw new Error("Called performUpdate with a null node!");
      }
      startTime = this.timestamp();
      if (!escalating) {
        this.saveSelection();
      }
      path = this.getPathTo(node);
      pathInfo = this.allPaths[path];
      if (pathInfo == null) {
        throw new Error("Can not find path info for path " + path);
      }
      if (this.mappings[path] == null) {
        throw new error("Can not find mappings for path " + path);
      }
      if (pathInfo.node === node && pathInfo.content === this.getNodeContent(node)) {
        prefix = path + "/";
        pathsToDrop = p;
        pathsToDrop = [];
        _ref = this.allPaths;
        for (p in _ref) {
          data = _ref[p];
          if (this.stringStartsWith(p, prefix)) {
            pathsToDrop.push(p);
          }
        }
        for (_i = 0, _len = pathsToDrop.length; _i < _len; _i++) {
          p = pathsToDrop[_i];
          delete this.mappings[p];
          delete this.allPaths[p];
        }
        this.collectPathsForNode(node);
        if (pathInfo.node === this.pathStartNode) {
          console.log("Ended up rescanning the whole doc.");
          this.collectStrings(node, path, null, 0, 0);
        } else {
          parentPath = this.parentPath(path);
          parentPathInfo = this.allPaths[parentPath];
          if (parentPathInfo == null) {
            throw new Error("While performing update on node " + path + ", no path info found for parent path: " + parentPath);
          }
          parentMappings = this.mappings[parentPath];
          if (parentMappings == null) {
            throw new Error("While performing update on node " + path + ", no mappings info found for parent path: " + parentPath);
          }
          oldIndex = this.mappings[path].start - parentMappings.start;
          this.collectStrings(node, path, parentPathInfo.content, parentMappings.start, oldIndex);
        }
      } else {
        if (pathInfo.node !== this.pathStartNode) {
          parentNode = node.parentNode != null ? node.parentNode : (parentPath = this.parentPath(path), this.lookUpNode(parentPath));
          this.performUpdateOnNode(parentNode, true);
        } else {
          console.log("I can not go up, since I'm already at path start node. Barking out.");
          throw new Error("Can not keep up with the changes, since even the node configured as path start node was replaced.");
        }
      }
      if (!escalating) {
        return this.restoreSelection();
      }
    };

    DomTextMapper.prototype.getRangeForPath = function(path) {
      var result;
      result = this.mappings[path];
      if (result == null) {
        throw new Error("Found no range for path '" + path + "'!");
      }
      if (this.restricted) {
        result = $.extend({}, result);
        result.pathInfo = $.extend({}, result.pathInfo);
        delete result.pathInfo.node;
      }
      return result;
    };

    DomTextMapper.prototype.getMappingsForRanges = function(ranges, path) {
      var cleanMapping, cleanNode, mapping, mappings, node, range;
      if (path == null) {
        path = null;
      }
      mappings = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ranges.length; _i < _len; _i++) {
          range = ranges[_i];
          _results.push(mapping = this.getMappingsForRange(range.start, range.end, path));
        }
        return _results;
      }).call(this);
      if (this.restricted) {
        mappings = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = mappings.length; _i < _len; _i++) {
            mapping = mappings[_i];
            cleanMapping = $.extend({}, mapping);
            delete cleanMapping.range;
            cleanMapping.nodes = (function() {
              var _j, _len1, _ref, _results1;
              _ref = cleanMapping.nodes;
              _results1 = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                node = _ref[_j];
                cleanNode = $.extend({}, node);
                cleanNode.element = $.extend({}, cleanNode.element);
                cleanNode.element.pathInfo = $.extend({}, cleanNode.element.pathInfo);
                delete cleanNode.element.pathInfo.node;
                _results1.push(cleanNode);
              }
              return _results1;
            })();
            _results.push(cleanMapping);
          }
          return _results;
        })();
      }
      return mappings;
    };

    DomTextMapper.prototype.getContentForPath = function(path) {
      if (path == null) {
        path = null;
      }
      if (path == null) {
        path = this.getDefaultPath();
      }
      return this.allPaths[path].content;
    };

    DomTextMapper.prototype.getLengthForPath = function(path) {
      if (path == null) {
        path = null;
      }
      if (path == null) {
        path = this.getDefaultPath();
      }
      return this.allPaths[path].length;
    };

    DomTextMapper.prototype.getContentForRange = function(start, end, path) {
      if (path == null) {
        path = null;
      }
      return this.getContentForPath(path).substr(start, end - start);
    };

    DomTextMapper.prototype.getContextForRange = function(start, end) {
      var content, prefix, prefixLen, prefixStart, suffix;
      content = this.getContentForPath();
      prefixStart = Math.max(0, start - CONTEXT_LEN);
      prefixLen = start - prefixStart;
      prefix = content.substr(prefixStart, prefixLen);
      suffix = content.substr(end, prefixLen);
      return [prefix.trim(), suffix.trim()];
    };

    DomTextMapper.prototype.getMappingsForRange = function(start, end, path) {
      var endInfo, endMatch, endNode, endOffset, endPath, mapping, matches, p, r, result, startInfo, startMatch, startNode, startOffset, startPath, _ref,
        _this = this;
      if (path == null) {
        path = null;
      }
      if (!((start != null) && (end != null))) {
        throw new Error("start and end is required!");
      }
      if (path != null) {
        this.scan(path);
      }
      if (this.scannedPath == null) {
        throw new Error("Can not run getMappingsFor() without existing mappings. Either supply a path to scan, or call scan() beforehand!");
      }
      matches = [];
      _ref = this.mappings;
      for (p in _ref) {
        mapping = _ref[p];
        if (mapping.atomic && this.regions_overlap(mapping.start, mapping.end, start, end)) {
          (function(mapping) {
            var full_match, match;
            match = {
              element: mapping
            };
            full_match = start <= mapping.start && mapping.end <= end;
            if (full_match) {
              match.full = true;
              match.wanted = mapping.content;
            } else {
              if (start <= mapping.start) {
                match.end = end - mapping.start;
                match.wanted = mapping.pathInfo.content.substr(0, match.end);
              } else if (mapping.end <= end) {
                match.start = start - mapping.start;
                match.wanted = mapping.pathInfo.content.substr(match.start);
              } else {
                match.start = start - mapping.start;
                match.end = end - mapping.start;
                match.wanted = mapping.pathInfo.content.substr(match.start, match.end - match.start);
              }
            }
            _this.computeSourcePositions(match);
            match.yields = mapping.pathInfo.node.data.substr(match.startCorrected, match.endCorrected - match.startCorrected);
            return matches.push(match);
          })(mapping);
        }
      }
      if (matches.length === 0) {
        throw new Error("No matches found for [" + start + ":" + end + "]!");
      }
      r = this.rootWin.document.createRange();
      startMatch = matches[0];
      startNode = startMatch.element.pathInfo.node;
      startPath = startMatch.element.pathInfo.path;
      startOffset = startMatch.startCorrected;
      if (startMatch.full) {
        r.setStartBefore(startNode);
        startInfo = startPath;
      } else {
        r.setStart(startNode, startOffset);
        startInfo = startPath + ":" + startOffset;
      }
      endMatch = matches[matches.length - 1];
      endNode = endMatch.element.pathInfo.node;
      endPath = endMatch.element.pathInfo.path;
      endOffset = endMatch.endCorrected;
      if (endMatch.full) {
        r.setEndAfter(endNode);
        endInfo = endPath;
      } else {
        r.setEnd(endNode, endOffset);
        endInfo = endPath + ":" + endOffset;
      }
      result = {
        nodes: matches,
        range: r,
        rangeInfo: {
          startPath: startPath,
          startOffset: startOffset,
          startInfo: startInfo,
          endPath: endPath,
          endOffset: endOffset,
          endInfo: endInfo
        },
        safeParent: r.commonAncestorContainer
      };
      return result;
    };

    DomTextMapper.prototype.timestamp = function() {
      return new Date().getTime();
    };

    DomTextMapper.prototype.stringStartsWith = function(string, prefix) {
      return prefix === string.substr(0, prefix.length);
    };

    DomTextMapper.prototype.parentPath = function(path) {
      return path.substr(0, path.lastIndexOf("/"));
    };

    DomTextMapper.prototype.domChangedSince = function(timestamp) {
      if ((this.lastDOMChange != null) && (timestamp != null)) {
        return this.lastDOMChange > timestamp;
      } else {
        return true;
      }
    };

    DomTextMapper.prototype.domStableSince = function(timestamp) {
      return !this.domChangedSince(timestamp);
    };

    DomTextMapper.prototype.getProperNodeName = function(node) {
      var nodeName;
      nodeName = node.nodeName;
      switch (nodeName) {
        case "#text":
          return "text()";
        case "#comment":
          return "comment()";
        case "#cdata-section":
          return "cdata-section()";
        default:
          return nodeName;
      }
    };

    DomTextMapper.prototype.getPathTo = function(node) {
      var pos, tempitem2, xpath;
      xpath = '';
      while (node !== this.rootNode) {
        pos = 0;
        tempitem2 = node;
        while (tempitem2) {
          if (tempitem2.nodeName === node.nodeName) {
            pos++;
          }
          tempitem2 = tempitem2.previousSibling;
        }
        xpath = (this.getProperNodeName(node)) + (pos > 1 ? "[" + pos + ']' : "") + '/' + xpath;
        node = node.parentNode;
      }
      xpath = (this.rootNode.ownerDocument != null ? './' : '/') + xpath;
      xpath = xpath.replace(/\/$/, '');
      return xpath;
    };

    DomTextMapper.prototype.collectPathsForNode = function(node) {
      var child, cont, path, _i, _len, _ref;
      cont = this.getNodeContent(node, false);
      if (cont.length) {
        path = this.getPathTo(node);
        this.allPaths[path] = {
          path: path,
          content: cont,
          length: cont.length,
          node: node
        };
      }
      if (node.hasChildNodes()) {
        _ref = node.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          this.collectPathsForNode(child);
        }
      }
      return null;
    };

    DomTextMapper.prototype.getBody = function() {
      return (this.rootWin.document.getElementsByTagName("body"))[0];
    };

    DomTextMapper.prototype.regions_overlap = function(start1, end1, start2, end2) {
      return start1 < end2 && start2 < end1;
    };

    DomTextMapper.prototype.lookUpNode = function(path) {
      var doc, node, results, _ref;
      doc = (_ref = this.rootNode.ownerDocument) != null ? _ref : this.rootNode;
      results = doc.evaluate(path, this.rootNode, null, 0, null);
      return node = results.iterateNext();
    };

    DomTextMapper.prototype.saveSelection = function() {
      var i, sel, _i, _ref, _ref1;
      sel = this.rootWin.getSelection();
      for (i = _i = 0, _ref = sel.rangeCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.oldRanges = sel.getRangeAt(i);
      }
      switch (sel.rangeCount) {
        case 0:
          return (_ref1 = this.oldRanges) != null ? _ref1 : this.oldRanges = [];
        case 1:
          return this.oldRanges = [this.oldRanges];
      }
    };

    DomTextMapper.prototype.restoreSelection = function() {
      var range, sel, _i, _len, _ref, _results;
      sel = this.rootWin.getSelection();
      sel.removeAllRanges();
      _ref = this.oldRanges;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        range = _ref[_i];
        _results.push(sel.addRange(range));
      }
      return _results;
    };

    DomTextMapper.prototype.selectNode = function(node, scroll) {
      var children, range, sel, sn, _ref;
      if (scroll == null) {
        scroll = false;
      }
      sel = this.rootWin.getSelection();
      sel.removeAllRanges();
      range = this.rootWin.document.createRange();
      if (USE_THEAD_TBODY_WORKAROUND && node.nodeType === Node.ELEMENT_NODE && ((_ref = node.tagName.toLowerCase()) === "thead" || _ref === "tbody") && node.hasChildNodes()) {
        children = node.childNodes;
        range.setStartBefore(children[0]);
        range.setEndAfter(children[children.length - 1]);
        sel.addRange(range);
      } else {
        if (USE_TABLE_TEXT_WORKAROUND && node.nodeType === Node.TEXT_NODE && node.parentNode.tagName.toLowerCase() === "table") {

        } else {
          range.setStartBefore(node);
          range.setEndAfter(node);
          sel.addRange(range);
        }
      }
      if (scroll) {
        sn = node;
        while (!(sn.scrollIntoViewIfNeeded != null)) {
          sn = sn.parentNode;
        }
        sn.scrollIntoViewIfNeeded();
      }
      return sel;
    };

    DomTextMapper.prototype.getNodeSelectionText = function(node, shouldRestoreSelection) {
      var sel, text;
      if (shouldRestoreSelection == null) {
        shouldRestoreSelection = true;
      }
      if (shouldRestoreSelection) {
        this.saveSelection();
      }
      sel = this.selectNode(node);
      text = sel.toString().trim().replace(/\n/g, " ").replace(/[ ][ ]+/g, " ");
      if (shouldRestoreSelection) {
        this.restoreSelection();
      }
      return text;
    };

    DomTextMapper.prototype.computeSourcePositions = function(match) {
      var dc, displayEnd, displayIndex, displayStart, displayText, sc, sourceEnd, sourceIndex, sourceStart, sourceText;
      sourceText = match.element.pathInfo.node.data.replace(/\n/g, " ");
      displayText = match.element.pathInfo.content;
      displayStart = match.start != null ? match.start : 0;
      displayEnd = match.end != null ? match.end : displayText.length;
      sourceIndex = 0;
      displayIndex = 0;
      while (!((sourceStart != null) && (sourceEnd != null))) {
        sc = sourceText[sourceIndex];
        dc = displayText[displayIndex];
        if (sc === dc) {
          if (displayIndex === displayStart) {
            sourceStart = sourceIndex;
          }
          displayIndex++;
          if (displayIndex === displayEnd) {
            sourceEnd = sourceIndex + 1;
          }
        }
        sourceIndex++;
      }
      match.startCorrected = sourceStart;
      match.endCorrected = sourceEnd;
      return null;
    };

    DomTextMapper.prototype.getNodeContent = function(node, shouldRestoreSelection) {
      if (shouldRestoreSelection == null) {
        shouldRestoreSelection = true;
      }
      return this.getNodeSelectionText(node, shouldRestoreSelection);
    };

    DomTextMapper.prototype.collectStrings = function(node, path, parentContent, parentIndex, index) {
      var atomic, child, childPath, children, content, endIndex, i, newCount, nodeName, oldCount, pathInfo, pos, startIndex, typeCount;
      if (parentContent == null) {
        parentContent = null;
      }
      if (parentIndex == null) {
        parentIndex = 0;
      }
      if (index == null) {
        index = 0;
      }
      pathInfo = this.allPaths[path];
      content = pathInfo != null ? pathInfo.content : void 0;
      if (!(content != null) || content === "") {
        return index;
      }
      startIndex = parentContent != null ? parentContent.indexOf(content, index) : index;
      if (startIndex === -1) {
        return index;
      }
      endIndex = startIndex + content.length;
      atomic = !node.hasChildNodes();
      this.mappings[path] = {
        pathInfo: pathInfo,
        start: parentIndex + startIndex,
        end: parentIndex + endIndex,
        atomic: atomic
      };
      if (this.declareMappings) {
        console.log("Found mappings for [" + this.mappings[path].start + ":" + this.mappings[path].end + "]: " + pathInfo.content);
      }
      if (!atomic) {
        children = node.childNodes;
        i = 0;
        pos = 0;
        typeCount = Object();
        while (i < children.length) {
          child = children[i];
          nodeName = this.getProperNodeName(child);
          oldCount = typeCount[nodeName];
          newCount = oldCount != null ? oldCount + 1 : 1;
          typeCount[nodeName] = newCount;
          childPath = path + "/" + nodeName + (newCount > 1 ? "[" + newCount + "]" : "");
          pos = this.collectStrings(child, childPath, content, parentIndex + startIndex, pos);
          i++;
        }
      }
      return endIndex;
    };

    return DomTextMapper;

  })();

}).call(this);
